需求:
a)	Hook指定方法
i.	一般方法
ii.	Native方法
iii.	静态方法
b)	提供jni层的通用回调接口
c)	提供java层的通用回调接口
d)	提供修改参数和返回值的功能
e)	可以同时hook多个方法


疑问：
也就是说 核心hook都在C层实现，C层同时提供JNI的回调接口以及给Java的回调接口

需要处理的参数转换有？:
C层的HOOk类设计:需要哪些必须的方法
修改参数和返回值的功能是Before和After都要？还是只需要Before

C层：
class art  :aosp的art类
class ArgsConverter : java与C的参数处理/堆栈转换
class Hook  :目前有安装hook的函数，不需要卸载功能，后需要支持多个hook


接口：
    virtual void After(JNIEnv *env, jobject thiz, jobjectArray args);
    virtual void Before(JNIEnv *env, jobject thiz, jobjectArray args);
    virtual void ChangeArgs();
    virtual void ChangeValue();、
    
功能统一来自C层的Hook，且有 // Before: 修改参数 // After: 修改返回值


@Trampline.S 这个跳板只是将hook点跳转到汇编，保存现场后调callback，执行完后恢复现场。如果要实现after，
我们需要在entry_point_from_quick_compiled_code_的结束ret的时候 进行Installhook，就可以修改返回值

void IHook::Before(JNIEnv *env, jobject thiz, jobjectArray args) {
    LOGV("IHook Before");

    MethodArgs currentArgs = ArgsConverter::parseArgsFromJArray(env, args);

    // 打印当前参数值
    const char* sz = env->GetStringUTFChars(currentArgs.str, nullptr);
    LOGV("After: ch-%c, f-%f, l-%d, d-%lf, str-%s, b-%d, n-%d",
         currentArgs.ch, currentArgs.f, currentArgs.l, currentArgs.d, sz, currentArgs.b, currentArgs.n);
    env->ReleaseStringUTFChars(currentArgs.str, sz);

    ChangeArgs();

    LOGV("IHook Before END");
    return;
};

void IHook::After(JNIEnv* env, jobject thiz, jobjectArray args) {
    LOGV("IHook After");

    MethodArgs currentArgs = ArgsConverter::parseArgsFromJArray(env, args);

    // 打印当前参数值
    const char* sz = env->GetStringUTFChars(currentArgs.str, nullptr);
    LOGV("After: ch-%c, f-%f, l-%d, d-%lf, str-%s, b-%d, n-%d",
         currentArgs.ch, currentArgs.f, currentArgs.l, currentArgs.d, sz, currentArgs.b, currentArgs.n);
    env->ReleaseStringUTFChars(currentArgs.str, sz);

    ChangeValue();

    LOGV("IHook After END");
    return;
}我这么写的话 如果用户不重写Before和After 是不是可以直接重写    virtual void ChangeArgs();
    virtual void ChangeValue();